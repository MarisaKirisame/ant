type list 'a =
  | Nil
  | Cons of 'a * list 'a;;

let rec list_length_tc = fun l len ->
  match l with
  | Nil -> len
  | Cons _ tail -> list_length_tc tail (len + 1);;

let list_length = fun l -> list_length_tc l 0;;

type unit = Unit;;

type option 'a =
  | None
  | Some of 'a;;

type symbol =
  | SLambda
  | SDefine
  | SQuote
  | SEq
  | SCons
  | SCond
  | SAtom
  | SCar
  | SCdr
  | SNull;;

type atom =
  | AVar of int
  | ANumber of int
  | ASymbol of symbol
  | ANIL;;

type expr =
  | EAtom of atom
  | ECons of expr * expr;;

type value =
  | VNumber of int
  | VSymbol of symbol
  | VQuote of expr
  | VNIL
  | VCons of value * value
  | VClosure of int * expr * env

and env_entry = EnvEntry of int * value

and env = MkEnv of list env_entry;;

let quote_expr = fun e -> ECons (EAtom (ASymbol SQuote)) e;;

let env_entry_name = fun ent ->
  match ent with
  | EnvEntry name _ -> name;;

let env_entry_value = fun ent ->
  match ent with
  | EnvEntry _ value -> value;;

(* let rec value_to_expr = fun v ->
  match v with
  | VNumber x -> EAtom (ANumber x)
  | VSymbol sym -> EAtom (ASymbol sym)
  | VQuote e -> quote_expr e
  | VNIL -> EAtom ANIL
  | VCons x y -> ECons (EAtom (ASymbol SCons)) (ECons (value_to_expr x) (ECons (value_to_expr y) (EAtom ANIL)))
  | VClosure _ _ _ -> failwith "value_to_expr: unexpected CLOSURE";; *)

let expr_is_symbol = fun e ->
  match e with
  | EAtom a ->
    (match a with
    | ASymbol sym -> Some sym
    | _ -> None)
  | _ -> None;;

let expr_is_var = fun e ->
  match e with
  | EAtom a ->
    (match a with
    | AVar i -> Some i
    | _ -> None)
  | _ -> None;;

let expr_is_num = fun e ->
  match e with
  | ECons fn t -> None
  | EAtom a ->
    match a with
    | ANumber x -> Some x
    | _ -> None;;

let expr_is_nil = fun e ->
  match e with
  | ECons fn t -> false
  | EAtom a ->
    match a with
    | ANIL -> true
    | _ -> false;;

(* let const_Nil = fun _ -> EAtom ANIL;; *)

(* let expr_false = fun _ -> EAtom ANIL;; *)

(* let expr_true = fun _ -> EAtom (ANumber 0);; *)

let value_false = fun _ -> VNIL;;

let value_true = fun _ -> VNumber 0;;

let unwrap_env = fun env ->
  match env with
  | MkEnv e -> e;;

let cons_env = fun x env ->
  match env with
  | MkEnv e ->
    MkEnv (Cons x e);;

let caddr_ = fun e ->
  match e with
  | ECons _ x ->
    match x with
    | ECons _ y ->
      match y with
      | ECons z _ -> z;;

let cadr_ = fun e ->
  match e with
  | ECons _ x ->
    match x with
    | ECons y _ -> y;;

let caar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons y _ -> y;;

let cdar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y -> y;;

let cddar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y ->
      match y with
      | ECons _ z -> z;;

let cadar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y ->
      match y with
      | ECons z _ -> z;;

let caddar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y ->
      match y with
      | ECons _ z ->
        match z with
        | ECons w _ -> w;;

let car_ = fun e ->
  match e with
  | ECons x _ -> x;;

let cdr_ = fun e ->
  match e with
  | ECons _ y -> y;;

let symbol_eq = fun x y ->
  match x with
  | SLambda ->
    (match y with
    | SLambda -> true
    | _ -> false)
  | SDefine ->
    (match y with
    | SDefine -> true
    | _ -> false)
  | SQuote ->
    (match y with
    | SQuote -> true
    | _ -> false)
  | SEq ->
    (match y with
    | SEq -> true
    | _ -> false)
  | SCons ->
    (match y with
    | SCons -> true
    | _ -> false)
  | SCond ->
    (match y with
    | SCond -> true
    | _ -> false)
  | SAtom ->
    (match y with
    | SAtom -> true
    | _ -> false)
  | SCar ->
    (match y with
    | SCar -> true
    | _ -> false)
  | SCdr ->
    (match y with
    | SCdr -> true
    | _ -> false);;

let rec atom_eq = fun x y ->
  match x with
  | AVar a ->
    (match y with
    | AVar b -> a = b
    | _ -> false)
  | ANumber a ->
    (match y with
    | ANumber b -> a = b
    | _ -> false)
  | ASymbol a ->
    (match y with
    | ASymbol b -> symbol_eq a b
    | _ -> false)
  | ANIL ->
    (match y with
    | ANIL -> true
    | _ -> false);;

let rec expr_eq = fun x y ->
  match x with
  | EAtom a ->
    (match y with
    | EAtom b -> atom_eq a b
    | _ -> false)
  | ECons _ _ -> false;; (* Scheme does this, and so do we *)

let rec value_eq = fun x y ->
  match x with
  | VNumber a ->
    (match y with
    | VNumber b -> a = b
    | _ -> false)
  | VSymbol a ->
    (match y with
    | VSymbol b -> symbol_eq a b
    | _ -> false)
  | VQuote a ->
    (match y with
    | VQuote b -> expr_eq a b
    | _ -> false)
  | VNIL ->
    (match y with
    | VNIL -> true
    | _ -> false)
  | VCons ah at -> false (* Scheme does this, and so do we *)
  | VClosure n1 e1 env1 -> false;;

let car = fun v ->
  match v with
  | VNumber _ -> failwith "car: cannot apply on NUMBER"
  | VSymbol _ -> failwith "car: cannot apply on SYMBOL"
  | VQuote e ->
    (match e with
    | ECons _ _ -> VQuote (car_ e)
    | _ -> failwith "car: PAIR expected" )
  | VNIL -> failwith "car: cannot apply on NIL"
  | VCons x _ -> x
  | VClosure _ _ _ -> failwith "car: cannot apply on CLOSURE";;

let cdr = fun v ->
  match v with
  | VNumber _ -> failwith "cdr: cannot apply on NUMBER"
  | VSymbol _ -> failwith "cdr: cannot apply on SYMBOL"
  | VQuote e ->
    (match e with
    | ECons _ _ -> VQuote (cdr_ e)
    | _ -> failwith "cdr: PAIR expected" )
  | VNIL -> failwith "cdr: cannot apply on NIL"
  | VCons _ y -> y
  | VClosure _ _ _ -> failwith "cdr: cannot apply on CLOSURE";;

let is_atom_ = fun v ->
  match v with
  | VNumber _ -> value_true Unit
  | VSymbol _ -> value_true Unit
  | VQuote _ -> value_true Unit
  | VNIL -> value_true Unit
  | VCons _ _ -> value_false Unit
  | VClosure _ _ _ -> value_true Unit;;

let is_eq_ = fun x y ->
  if value_eq x y then value_true Unit else value_false Unit;;

let rec lookup = fun i env ->
  match unwrap_env env with
  | Nil -> failwith "empty environment"
  | Cons head tail ->
    if env_entry_name head = i then
      env_entry_value head
    else
      lookup i (MkEnv tail);;

let rec pairlis = fun xs ys env ->
  match xs with
  | Nil -> env
  | Cons x x_tl ->
    match ys with
    | Nil -> failwith "pairlis: arguments too few"
    | Cons y tl ->
      pairlis x_tl tl (cons_env (EnvEntry x y) env);;

let rec destruct_names = fun names ->
  match names with
  | ECons a t ->
    match expr_is_num a with
    | Some x -> Cons x (destruct_names t)
    | _ -> failwith "destruct_names: impossible, names must be int literals"
  | _ -> Nil;;

let is_null_ = fun v ->
  match v with
  | VQuote e ->
    if expr_is_nil e then
      value_true Unit
    else
      value_false Unit
  | _ -> value_false Unit;;

let rec evlis = fun exps env ->
  match exps with
  | ECons hd tl ->
    Cons (eval hd env) (evlis tl env)
  | _ -> Nil

and evcon = fun clauses env ->
  match clauses with
  | ECons head tail ->
    if value_eq (eval (car_ head) env) (value_false Unit) then
      evcon tail env
    else
      eval (cadr_ head) env
  | _ -> failwith "no cond clause matched"

and eval = fun exp env ->
  match exp with
  | EAtom a ->
    (match a with
    | AVar i -> lookup i env
    | ANumber x -> VNumber x
    | ASymbol sym -> VSymbol sym
    | ANIL -> failwith "ill-formed expression: NIL")
  | ECons _ _ ->
    (match expr_is_symbol (car_ exp) with
    | Some sym ->
      (match sym with
      | SQuote -> VQuote (cadr_ exp)
      | SAtom -> is_atom_ (eval (cadr_ exp) env)
      | SEq -> is_eq_ (eval (cadr_ exp) env) (eval (caddr_ exp) env)
      | SCar -> car (eval (cadr_ exp) env)
      | SCdr -> cdr (eval (cadr_ exp) env)
      | SCons -> VCons (eval (cadr_ exp) env) (eval (caddr_ exp) env)
      | SCond -> evcon (cdr_ exp) env
      | SNull -> is_null_ (eval (cadr_ exp) env)
      | _ -> failwith "invalid symbol here")
    | None ->
      match car_ exp with
      | ECons _ _ ->
        (match expr_is_symbol (caar_ exp) with
        | Some sym ->
          (match sym with
          | SLambda -> (* ( lambda (i j) (+ #i #j) ) args... *)
            let params = destruct_names (cadar_ exp) in
            let body = caddar_ exp in
            let args = evlis (cdr_ exp) env in
            let env_new = pairlis params args env in
            eval body env_new
          | SDefine -> (* ( define f (i j) (+ #i #j) ) kont *)
            let lam = ECons (EAtom (ASymbol (SLambda))) (cddar_ exp) in
            let name = (match expr_is_num (cadar_ exp) with | None -> failwith "eval: function name must be int literal" | Some x -> x) in
            let closure = VClosure name lam env in (* we cannot setup env for self referencing now, so instead we store the id of the function *)
            let env_with_def = cons_env (EnvEntry name closure) env in
            let kont = cadr_ exp in
            eval kont env_with_def
          | SQuote -> failwith "unexpected function quote"
          | SEq -> failwith "unexpected function eq"
          | SCons -> failwith "unexpected function cons"
          | SCond -> failwith "unexpected function cond"
          | SAtom -> failwith "unexpected function atom"
          | SCar -> failwith "unexpected function car"
          | SCdr -> failwith "unexpected function cdr"
          | SNull -> failwith "unexpected function null"
          | _ -> failwith "1")
        | None ->
          (match caar_ exp with
          | EAtom a ->
            (match a with
            | AVar _ -> failwith "unexpected function var"
            | ANumber _ -> failwith "unexpected function number"
            | ASymbol _ -> failwith "invalid symbol here"
            | ANIL -> failwith "unexpected function nil")
          | ECons _ _ -> failwith "unexpected CONS"))
      | _ ->
        (match expr_is_var (car_ exp) with
        | Some i ->
          (match lookup i env with
          | VNumber _ -> failwith "NUMBER is not PROCEDURE"
          | VSymbol _ -> failwith "SYMBOL is not PROCEDURE"
          | VQuote _ -> failwith "QUOTE is not PROCEDURE"
          | VNIL -> failwith "NIL is not PROCEDURE"
          | VCons _ _ -> failwith "PAIR is not PROCEDURE"
          | VClosure name lam captured ->
            let env_self = cons_env (EnvEntry name (VClosure name lam captured)) captured in
            eval (ECons lam (cdr_ exp)) env_self)
        | None ->
          (match car_ exp with
          | EAtom a ->
            (match a with
            | ANumber _ -> failwith "NUMBER is not PROCEDURE"
            | ANIL -> failwith "NIL is not PROCEDURE"
            | _ -> failwith "impossible")
          | _ -> failwith "impossible")));;
(* 
let evalquote = fun fn args ->
  eval (ECons fn args) (MkEnv Nil);; *)
