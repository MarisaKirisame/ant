type list 'a =
  | Nil
  | Cons of 'a * list 'a;;

let rec list_length_tc = fun l len ->
  match l with
  | Nil -> len
  | Cons _ tail -> list_length_tc tail (len + 1);;

let list_length = fun l -> list_length_tc l 0;;

type unit = Unit;;

type option 'a =
  | None
  | Some of 'a;;

type symbol =
  | SLambda
  | SDefine
  | SQuote
  | SEq
  | SIf
  | SDefvar
  | SCons
  | SCond
  | SAtom
  | SPair
  | SSymbol
  | SCar
  | SCdr
  | SNull
  | STrue
  | SFalse
  | SError
  | SVar;;

type atom =
  | AVar of int
  | ANumber of int
  | ASymbol of symbol
  | ANIL;;

type expr =
  | EAtom of atom
  | ECons of expr * expr;;

type value =
  | VNumber of int
  | VSymbol of symbol
  | VQuote of expr
  | VNIL
  | VCons of value * value
  | VClosure of int * expr

and env_entry = EnvEntry of int * value

and env = MkEnv of list env_entry;;

let quote_expr = fun e -> ECons (EAtom (ASymbol SQuote)) e;;

let env_entry_name = fun ent ->
  match ent with
  | EnvEntry name _ -> name;;

let env_entry_value = fun ent ->
  match ent with
  | EnvEntry _ value -> value;;

let expr_is_symbol = fun e ->
  match e with
  | EAtom a ->
    (match a with
    | ASymbol sym -> Some sym
    | _ -> None)
  | _ -> None;;

let expr_is_var = fun e ->
  match e with
  | EAtom a ->
    (match a with
    | AVar i -> Some i
    | _ -> None)
  | _ -> None;;

let expr_is_num = fun e ->
  match e with
  | ECons fn t -> None
  | EAtom a ->
    match a with
    | ANumber x -> Some x
    | _ -> None;;

let expr_is_nil = fun e ->
  match e with
  | ECons fn t -> false
  | EAtom a ->
    match a with
    | ANIL -> true
    | _ -> false;;

let value_is_number_or_quote_number = fun v ->
  match v with
  | VNumber x -> Some x
  | VQuote e -> expr_is_num e
  | _ -> None;;

(* let const_Nil = fun _ -> EAtom ANIL;; *)

(* let expr_false = fun _ -> EAtom ANIL;; *)

(* let expr_true = fun _ -> EAtom (ANumber 0);; *)

let value_false = fun _ -> VNIL;;

let value_true = fun _ -> VNumber 0;;

let unwrap_env = fun env ->
  match env with
  | MkEnv e -> e;;

let cons_env = fun x env ->
  match env with
  | MkEnv e ->
    MkEnv (Cons x e);;

let caddr_ = fun e ->
  match e with
  | ECons _ x ->
    match x with
    | ECons _ y ->
      match y with
      | ECons z _ -> z;;

let cadddr_ = fun e ->
  match e with
  | ECons _ x ->
    match x with
    | ECons _ y ->
      match y with
      | ECons _ z ->
        match z with
        | ECons w _ -> w;;

let cadr_ = fun e ->
  match e with
  | ECons _ x ->
    match x with
    | ECons y _ -> y;;

let caar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons y _ -> y;;

let cdar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y -> y;;

let cddar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y ->
      match y with
      | ECons _ z -> z;;

let cadar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y ->
      match y with
      | ECons z _ -> z;;

let caddar_ = fun e ->
  match e with
  | ECons x _ ->
    match x with
    | ECons _ y ->
      match y with
      | ECons _ z ->
        match z with
        | ECons w _ -> w;;

let car_ = fun e ->
  match e with
  | ECons x _ -> x;;

let cdr_ = fun e ->
  match e with
  | ECons _ y -> y;;

let symbol_eq = fun x y ->
  match x with
  | SLambda ->
    (match y with
    | SLambda -> true
    | _ -> false)
  | SDefine ->
    (match y with
    | SDefine -> true
    | _ -> false)
  | SQuote ->
    (match y with
    | SQuote -> true
    | _ -> false)
  | SEq ->
    (match y with
    | SEq -> true
    | _ -> false)
  | SDefvar ->
    (match y with
    | SDefvar -> true
    | _ -> false)
  | SIf ->
    (match y with
    | SIf -> true
    | _ -> false)
  | SCons ->
    (match y with
    | SCons -> true
    | _ -> false)
  | SCond ->
    (match y with
    | SCond -> true
    | _ -> false)
  | SAtom ->
    (match y with
    | SAtom -> true
    | _ -> false)
  | SPair ->
    (match y with
    | SPair -> true
    | _ -> false)
  | SSymbol ->
    (match y with
    | SSymbol -> true
    | _ -> false)
  | STrue ->
    (match y with
    | STrue -> true
    | _ -> false)
  | SFalse ->
    (match y with
    | SFalse -> true
    | _ -> false)
  | SCar ->
    (match y with
    | SCar -> true
    | _ -> false)
  | SCdr ->
    (match y with
    | SCdr -> true
    | _ -> false)
  | SNull ->
    (match y with
    | SNull -> true
    | _ -> false)
  | SError ->
    (match y with
    | SError -> true
    | _ -> false)
  | SVar ->
    (match y with
    | SVar -> true
    | _ -> false);;

let rec atom_eq = fun x y ->
  match x with
  | AVar a ->
    (match y with
    | AVar b -> a = b
    | _ -> false)
  | ANumber a ->
    (match y with
    | ANumber b -> a = b
    | _ -> false)
  | ASymbol a ->
    (match y with
    | ASymbol b -> symbol_eq a b
    | _ -> false)
  | ANIL ->
    (match y with
    | ANIL -> true
    | _ -> false);;

let rec expr_eq = fun x y ->
  match x with
  | EAtom a ->
    (match y with
    | EAtom b -> atom_eq a b
    | _ -> false)
  | ECons _ _ -> false;; (* Scheme does this, and so do we *)

let rec value_eq = fun x y ->
  match x with
  | VNumber a ->
    (match y with
    | VNumber b -> a = b
    | VQuote e -> (* as per Scheme, `'n = n` holds while `''n = n` does not hold *)
      (match expr_is_num e with
      | None -> false
      | Some m -> a = m)
    | _ -> false)
  | VSymbol a ->
    (match y with
    | VSymbol b -> symbol_eq a b
    | _ -> false)
  | VQuote a ->
    (match y with
    | VQuote b -> expr_eq a b
    | VNumber n ->
      (match expr_is_num a with
      | None -> false
      | Some m -> n = m)
    | _ -> false)
  | VNIL ->
    (match y with
    | VNIL -> true
    | _ -> false)
  | VCons ah at -> false (* Scheme does this, and so do we *)
  | VClosure _ _ -> false;;

let car = fun v ->
  match v with
  | VNumber _ -> failwith "car: cannot apply on NUMBER"
  | VSymbol _ -> failwith "car: cannot apply on SYMBOL"
  | VQuote e ->
    (match e with
    | ECons _ _ -> VQuote (car_ e)
    | _ -> failwith "car: PAIR expected" )
  | VNIL -> failwith "car: cannot apply on NIL"
  | VCons x _ -> x
  | VClosure _ _ -> failwith "car: cannot apply on CLOSURE";;

let cdr = fun v ->
  match v with
  | VNumber _ -> failwith "cdr: cannot apply on NUMBER"
  | VSymbol _ -> failwith "cdr: cannot apply on SYMBOL"
  | VQuote e ->
    (match e with
    | ECons _ _ -> VQuote (cdr_ e)
    | _ -> failwith "cdr: PAIR expected" )
  | VNIL -> failwith "cdr: cannot apply on NIL"
  | VCons _ y -> y
  | VClosure _ _ -> failwith "cdr: cannot apply on CLOSURE";;

let is_atom_ = fun v ->
  match v with
  | VNumber _ -> value_true Unit
  | VSymbol _ -> value_true Unit
  | VQuote _ -> value_true Unit
  | VNIL -> value_true Unit
  | VCons _ _ -> value_false Unit
  | VClosure _ _ -> value_true Unit;;

let is_pair_ = fun v ->
  match v with
  | VNumber _ -> value_false Unit
  | VSymbol _ -> value_false Unit
  | VQuote e ->
    (match e with
    | ECons _ _ -> value_true Unit
    | _ -> value_false Unit )
  | VNIL -> value_false Unit
  | VCons _ _ -> value_true Unit
  | VClosure _ _ -> value_false Unit;;

let is_symbol_ = fun v ->
  match v with
  | VNumber _ -> value_false Unit
  | VSymbol _ -> value_true Unit
  | VQuote e ->
    (match expr_is_symbol e with
    | Some _ -> value_true Unit
    | _ -> value_false Unit )
  | VNIL -> value_false Unit
  | VCons _ _ -> value_false Unit
  | VClosure _ _ -> value_false Unit;;

let is_eq_ = fun x y ->
  if value_eq x y then value_true Unit else value_false Unit;;

let rec lookup = fun i env ->
  match unwrap_env env with
  | Nil -> failwith "empty environment"
  | Cons head tail ->
    if env_entry_name head = i then
      env_entry_value head
    else
      lookup i (MkEnv tail);;

let rec pairlis = fun xs ys env ->
  match xs with
  | Nil -> env
  | Cons x x_tl ->
    match ys with
    | Nil -> failwith "pairlis: arguments too few"
    | Cons y tl ->
      pairlis x_tl tl (cons_env (EnvEntry x y) env);;

let rec destruct_names = fun names ->
  match names with
  | ECons a t ->
    (match expr_is_num a with
    | Some x -> Cons x (destruct_names t)
    | _ -> failwith "destruct_names: impossible, names must be int literals" )
  | EAtom a ->
    match a with
    | ANIL -> Nil
    | _ -> failwith "destruct_names: impossible";;

let is_null_ = fun v ->
  match v with
  | VQuote e ->
    if expr_is_nil e then
      value_true Unit
    else
      value_false Unit
  | _ -> value_false Unit;;

let rec evlis = fun exps env ->
  match exps with
  | ECons hd tl ->
    Cons (eval hd env) (evlis tl env)
  | _ -> Nil

and evcon = fun clauses env ->
  match clauses with
  | ECons head tail ->
    if value_eq (eval (car_ head) env) (value_false Unit) then
      evcon tail env
    else
      eval (cadr_ head) env
  | _ -> failwith "no cond clause matched"

and eval = fun exp env ->
  match exp with
  | EAtom a ->
    (match a with
    | AVar i -> lookup i env
    | ANumber x -> VNumber x
    | ASymbol sym ->
      (match sym with
      | STrue -> value_true Unit
      | SFalse -> value_false Unit
      | _ -> failwith "cannot directly evaluate this symbol")
    | ANIL -> failwith "ill-formed expression: NIL")
  | ECons _ _ ->
    (match expr_is_symbol (car_ exp) with
    | Some sym ->
      (match sym with
      | SQuote -> VQuote (cadr_ exp)
      | SAtom -> is_atom_ (eval (cadr_ exp) env)
      | SPair -> is_pair_ (eval (cadr_ exp) env)
      | SSymbol -> is_symbol_ (eval (cadr_ exp) env)
      | SEq -> is_eq_ (eval (cadr_ exp) env) (eval (caddr_ exp) env)
      | SCar -> car (eval (cadr_ exp) env)
      | SCdr -> cdr (eval (cadr_ exp) env)
      | SIf ->
        let c = cadr_ exp in
        let t = caddr_ exp in
        let f = cadddr_ exp in
        let c_ = eval c env in
        if value_eq c_ (value_false Unit) then
          eval f env
        else
          eval t env
      | SCons -> VCons (eval (cadr_ exp) env) (eval (caddr_ exp) env)
      | SCond -> evcon (cdr_ exp) env
      | SNull -> is_null_ (eval (cadr_ exp) env)
      | STrue -> failwith "true is not PROCEDURE"
      | SFalse -> failwith "false is not PROCEDURE"
      | SVar -> failwith "eval: symbol var is not intended to be used this way"
      | SError ->
        let err = eval (cadr_ exp) env in
        let err_code = (match value_is_number_or_quote_number err with | None -> failwith "eval: user error code must evalutes to integer" | Some x -> x) in
        failwith_int err_code
      | _ -> failwith "invalid symbol here" )
    | None ->
      match car_ exp with
      | ECons _ _ ->
        (match expr_is_symbol (caar_ exp) with
        | Some sym ->
          (match sym with 
          | SLambda -> (* ( lambda (i j) (+ #i #j) ) args... *)
            let params = destruct_names (cadar_ exp) in
            let body = caddar_ exp in
            let args = evlis (cdr_ exp) env in
            let env_new = pairlis params args env in
            eval body env_new
          | SDefine -> (* ( define f (i j) (+ #i #j) ) kont *)
            let lam = ECons (EAtom (ASymbol (SLambda))) (cddar_ exp) in
            let name = (match expr_is_num (cadar_ exp) with | None -> failwith "eval: function name must be int literal" | Some x -> x) in
            let closure = VClosure name lam in
            let env_with_def = cons_env (EnvEntry name closure) env in
            let kont = cadr_ exp in
            eval kont env_with_def
          | SDefvar -> (* (defvar i val) kont *)
            let val = eval (caddar_ exp) env in
            let name = (match expr_is_num (cadar_ exp) with | None -> failwith "eval: defvar name must be int literal" | Some x -> x) in
            let env_with_def = cons_env (EnvEntry name val) env in
            let kont = cadr_ exp in
            eval kont env_with_def
          | SQuote -> failwith "unexpected function quote"
          | SEq -> failwith "unexpected function eq"
          | SCons -> failwith "unexpected function cons"
          | SIf -> failwith "unexpected function if"
          | SCond -> failwith "unexpected function cond"
          | SAtom -> failwith "unexpected function atom"
          | SPair -> failwith "unexpected function pair"
          | SSymbol -> failwith "unexpected function symbol"
          | STrue -> failwith "unexpected function true"
          | SFalse -> failwith "unexpected function false"
          | SCar -> failwith "unexpected function car"
          | SCdr -> failwith "unexpected function cdr"
          | SNull -> failwith "unexpected function null"
          | SError -> failwith "unexpected function error"
          | SVar -> failwith "eval: symbol var is not intended to be used this way"
          | _ -> failwith "1" )
        | None ->
          (match caar_ exp with
          | EAtom a ->
            (match a with
            | AVar _ -> failwith "unexpected function var"
            | ANumber _ -> failwith "unexpected function number"
            | ASymbol _ -> failwith "invalid symbol here"
            | ANIL -> failwith "unexpected function nil" )
          | ECons _ _ -> failwith "unexpected CONS" ))
      | _ ->
        (match expr_is_var (car_ exp) with
        | Some i ->
          (match lookup i env with
          | VNumber _ -> failwith "NUMBER is not PROCEDURE"
          | VSymbol _ -> failwith "SYMBOL is not PROCEDURE"
          | VQuote _ -> failwith "QUOTE is not PROCEDURE"
          | VNIL -> failwith "NIL is not PROCEDURE"
          | VCons _ _ -> failwith "PAIR is not PROCEDURE"
          | VClosure name lam ->
            eval (ECons lam (cdr_ exp)) env)
        | None ->
          (match car_ exp with
          | EAtom a ->
            (match a with
            | ANumber _ -> failwith "NUMBER is not PROCEDURE"
            | ANIL -> failwith "NIL is not PROCEDURE"
            | _ -> failwith "impossible" )
          | _ -> failwith "impossible" )));;
(* 
let evalquote = fun fn args ->
  eval (ECons fn args) (MkEnv Nil);; *)
