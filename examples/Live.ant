type nat = 
  | Z 
  | S of nat
;;

type list 'a =
  | Nil
  | Cons of 'a * list 'a
;;

let index = fun x n ->
  match x with
  | Cons (xh, xt) -> 
    (match n with
    | Z -> xh
    | S m -> index xt m);;

type expr =
  | EInt of int
  | EPlus of expr * expr
  | EVar of nat
  | EAbs of expr
  | EApp of expr * expr
  | ELet of expr * expr
  | ETrue
  | EFalse
  | EIf of expr * expr * expr
  | ENil
  | ECons of expr * expr
  | EMatchList of expr * expr * expr
  | EFix of expr
  | EHole
;;

type value = 
  | VInt of int
  | VAbs of expr * list value
  | VTrue
  | VFalse
  | VNil
  | VCons of value * value
  | VFix of expr * list value
;;

let vadd = fun l r ->
  match l with
  | VInt li ->
    (match r with 
    | VInt ri -> VInt (li + ri))
;;

let eval = fun expr env ->
  match expr with
  | EInt i -> VInt i
  | EPlus (x, y) -> vadd (eval x env) (eval y env)
  | EVar idx -> index env idx
  | EAbs e -> VAbs e env
  | ELet (lhs, rhs) -> eval rhs (Cons (eval lhs env) env)
  | EFix e -> VFix e env
  | EApp (f, x) ->
    let fv = eval f env in
    let xv = eval x env in
    (match fv with 
    | VAbs (e, env_) -> eval e (Cons xv env_)
    | VFix (e, env_) -> eval e (Cons xv (Cons fv env_)))
  (*| ETrue -> VTrue
  | EFalse -> VFalse
  | EIf (i, t, e) -> 
    (match eval i env with
    | VTrue -> eval t env
    | VFalse -> eval e env)
  | ENil -> VNil
  | ECons (x, xs) -> VCons (eval x env) (eval xs env)
  | EMatchList (v, n, c) ->
    (match eval v env with
    | VNil -> eval n env
    | VCons (x, xs) -> eval c (Cons xs (Cons x env)))*)
;;