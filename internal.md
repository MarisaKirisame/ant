# Ant Architecture & Memoisation Guide

This document explains how the Ant compiler and runtime work together to implement
prefix memoisation for the CEK machine.  It summarises the major OCaml modules,
their responsibilities, and the data structures that make memo reuse possible.

## Compiler Pipeline

1. **Parsing** – `Lexer.mll`, `Tokens.mly`, and `Parser.mly` translate source text
   into the algebraic syntax defined in `Syntax.ml`.  Derived printers in
   `Syntax.pp_*` make it easy to debug intermediate trees.
2. **Name resolution** – `Resolve.ml` traverses a program and upgrades references
   to known functions from `Var` to `GVar`.  This happens before type inference so
   the rest of the pipeline can treat global functions specially.
3. **Type inference** – `Tyck.ml` implements a constraint-based Hindley–Milner
   solver.  It produces pretty-printers (`Tyck.pp_inferred`) that the CLI exposes via
   `--tyck`.
4. **Normalisation passes** – `Transform.ml` contains CPS and defunctionalisation
   passes.  Pattern compilation utilities live in `Pat.ml`.
5. **Code generation** – Two back-ends consume the transformed program:
   - `CompileSeq.ml` emits a pure interpreter expressed in terms of the `Seq`
     combinators.  This is useful for comparison runs without the memo table.
   - `CompileMemo.ml` builds the memoising CEK machine using the IR DSL in
     `Code.ml`/`Ir.ml`.  It registers constructors, synthesises continuations,
     and produces one OCaml function per program point.  The CLI flag `--cek`
     pretty-prints this output.
6. **Drivers** – `bin/main.ml` wires the pipeline together, exposing flags for
   each intermediate so that developers can inspect or regenerate artifacts.

Running `make run` wraps these steps: it regenerates the compiled modules
under `generated/`, formats with `dune fmt`, and executes `GeneratedMain`.

## Runtime Representation

### Words and Sequences (`Word.ml`, `Seq.ml`)
- Data is serialised as lists of tagged machine words.  Tag `0` denotes an
  integer literal; tag `1` denotes a constructor index.  Additional tags can be
  added as needed.
- `Seq.seq` wraps a finger tree (`BatFingerTree.Generic.fg`) annotated with the
  `measure` monoid.  Each measure stores length, total degree, and the maximum
  prefix degree so that Ant can split values in logarithmic time.
- `Seq.pop_n`, `Seq.split`, and `Seq.splits` are the building blocks used by the
  memo system to carve out slices during substitution.

### Values, References, and Stores (`Value.ml`, `Reference.ml`, `State.ml`)
- `Value.seq` extends `Seq.seq` with a second measure that also carries a
  cryptographic hash (`Hash.MCRC32C`).  The hash is disabled automatically when a
  slice contains deferred `Reference` nodes, because those must be resolved later.
- References encode “holes” in a value: `{ src; offset; values_count }`.  The
  source identifies whether the data came from the environment (`E`), memo store
  (`S`), or continuation (`K`).
- `State.state` captures the CEK triple along with a step counter.  Evaluator
  transitions live in the `exp.step` closures generated by `CompileMemo.ml`.
- `State.world` bundles a state, the memo store (a `Dynarray` of values), and the
  mutable memo trie node currently being updated.

### Hashes (`Hash.ml`)
- Contains several monoid hash implementations.  `Memo` uses `MCRC32C` by
  default, but `Hash.SL2` and `Hash.DebugHash` are available for benchmarking and
  fuzzing.

## Prefix Memo Table (`Memo.ml`)

The memo trie stores execution fragments keyed by slices of CEK state.

1. **Lookup phase** – Starting from the current node, Ant issues fetch requests
   (`fetch_request`) for the environment, store, or continuation.  Each request
   asks for a fixed number of values, measured in `Seq` degrees.
2. **Fetching** – `fetch_value` loads the requested words.  If the fetch produces
   leftover prefixes/suffixes they are converted to `Reference`s and appended to
   the store so later requests can reuse them.
3. **Hashing & branching** – The fetched chunk is hashed (`fr_to_fh`) and used to
   pick the next child.  Hash collisions are theoretically possible but rare; if
   they occur Ant falls back to stepping instead of skipping.
4. **Registering progress** – `register_memo_need_unfetched` ensures that if a node
   could not fetch everything it needed we record that fact, so subsequent runs
   continue the traversal rather than starting over.
5. **Fast forwarding** – When a memoised fragment is available, `fast_forward_to`
   substitutes the live bindings into the recorded state and resumes evaluation
   from the memo target.  Substitution works recursively by calling `subst` on
   every `Reference`.

The memo trie guarantees progress by transitioning nodes through
`BlackHole -> Halfway -> Need/Done`.  Once a node reaches `Done` the enclosed CEK
state can be reused without repeating the intermediate transitions.

## Dependency Tracking (Current)

This section summarises how Ant tracks dependencies inside the memoising CEK VM
today.  It pulls together the responsibilities of `Memo.ml`, `Value.ml`,
`Seq.ml`, and `State.ml`.

### Goals

- Prevent re-executing CEK steps when rerunning programs with identical inputs.
- Record precisely which slices of the CEK state must be materialised to replay
  a cached fragment.
- Detect missing prerequisites early so we can resume stepping rather than
  jumping to a stale state.

Dependency tracking reuses the CEK state, source identifiers, and finger-tree
values described in **Runtime Representation**.  The dependency-specific
bookkeeping is that every `Reference` records `src`, `offset`, and
`values_count`, making each memo entry explicit about the slice that must be
materialised before reuse.

Degree and hash measures flow through the same structures: a fully realised
slice retains its length and CRC32C hash (`Value.measure.full`), while the
presence of any `Reference` clears the hash and signals that dependency
resolution still has work to do.

### Memo Nodes and Dependency State

- **Memo array (`State.memo_t`)** stores one `memo_node_t ref` per program
  counter.
- **Node variants (`State.memo_node_t`)**:
  - `BlackHole`: untouched; no dependency information yet.
  - `Halfway`: a partially evaluated state that advanced the program but still
    requires more work.
  - `Need`: records a `fetch_request` (source, offset, word count) plus a hash
    table of observed fetch results so we can branch on their content.
  - `Done`: a fully materialised state ready for fast-forwarding.
- **Lookup tables (`State.lookup_t`)** map content hashes to child nodes,
  forming a trie over the fetched prefixes.

### Execution Flow

1. **Locate (`Memo.locate`)** walks the memo nodes from the current state,
   cloning values into a transient `tstate` that marks each slot as materialised
   (`Here`) or deferred (`Lower`).
2. **Resolve (`Memo.resolve_seq`)** encounters a `Reference` and records the
   missing dependency via `register_memo_need_unfetched`, switching the node to
   `Need`.
3. **Fetch (`Memo.fetch_value`)** pulls the requested slice from the source.  Any
   unused prefix/suffix becomes a new `Reference` stored in the memo store for
   reuse.
4. **Hash & branch** – we hash the fetched words (`Memo.fr_to_fh`) and index the
   `lookup` table.  Absent hashes allocate new child nodes so divergent prefix
   contents lead to distinct dependency paths.
5. **Fast-forward (`Memo.fast_forward_to`)** substitutes all resolved
   dependencies and jumps to the cached state once the node reaches `Done`.
6. **Record progress (`Memo.improve`)** updates nodes to `Halfway` or `Done`,
   asserting that step counts increase so reuse never regresses execution.

### Invariants

- **Depth discipline** – references only point to equal or shallower depths,
  preventing cycles on unfetched data.
- **Monotone fetch lengths** – `Memo.get_word_count` grows exponentially with
  store depth, guaranteeing we eventually materialise entire structures.
- **Hash coherence** – cached hashes exist only for fully materialised slices;
  encountering a reference forces a refetch the first time we need its content.
- **Step monotonicity** – `Memo.improve` refuses to downgrade `Need`/`Done`
  nodes and ensures every reuse advances the CEK step counter.

### Known Limitations

- **Partial fetch churn** – repeated small fetches can occur when references keep
  slicing the same value before exponential growth kicks in.
- **Hash collisions** – CRC32C collisions fall back to normal stepping; frequent
  collisions would erode dependency precision.
- **Granularity** – dependencies are tracked at slice boundaries, not at the
  level of individual continuation arguments.
- **Store retention** – the store is append-only; we rely on future fetches to
  reuse indices and do not currently garbage collect old slices.

## Code Generation Helpers (`Code.ml`, `Ir.ml`)

- `Code.ml` offers a small EDSL for describing OCaml expressions with hole types
  such as `world -> unit`.  Functions like `lam`, `app`, `seq`, and `let_in`
  construct the IR nodes.
- `Ir.ml` defines the lower-level AST that is eventually pretty-printed.  It
  performs trivial optimisations such as flattening nested sequences so the
  generated OCaml code stays readable.
- `CompileMemo.ml` uses these helpers to stage:
  - constructor registration (`Memo.set_constructor_degree`, `Memo.from_constructor`);
  - continuation tables (the `ctx.conts` dynarray);
  - CEK program counters (`pc`) that map to `exp.step` closures.

## Generated Modules

- `generated/TestSeq.ml` and `generated/TestCEK.ml` are produced from
  `examples/Test.ant` and mirror the output of `--print-ant`/`--cek`.
- `generated/LiveCEK.ml` contains a hand-written demonstration CEK machine with
  Nat/List examples; `GeneratedMain.ml` runs it to smoke-test the memo runtime.
- These files are overwritten by `make run`.  Treat them as build artifacts.

## Testing & Benchmarking

- `test/test_ant.ml` exercises the monoid hash implementations and the custom
  integer map (`Intmap.ml`).
- Microbenchmarks in `bench/*.ml` compare the hash implementations and list
  operations.  Run them with `dune exec bench/<name>.exe`.

## Further Work

Potential areas for improvement that surfaced while reading the code:

- Finish breaking this document into smaller, topic-focused guides (memo trie,
  compiler pipeline, runtime).
- Document the CPS/defunctionalisation transformations in more depth, including
  the free-variable handling in `Transform.ml`.
- Expand the test suite to cover CEK execution traces and memo hit/miss ratios.
