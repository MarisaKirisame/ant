# Ant Architecture & Memoisation Guide

This document explains how the Ant compiler and runtime work together to implement
prefix memoisation for the CEK machine.  It summarises the major OCaml modules,
their responsibilities, and the data structures that make memo reuse possible.

## Compiler Pipeline

1. **Parsing** – `Lexer.mll`, `Tokens.mly`, and `Parser.mly` translate source text
   into the algebraic syntax defined in `Syntax.ml`.  Derived printers in
   `Syntax.pp_*` make it easy to debug intermediate trees.
2. **Name resolution** – `Resolve.ml` traverses a program and upgrades references
   to known functions from `Var` to `GVar`.  This happens before type inference so
   the rest of the pipeline can treat global functions specially.
3. **Type inference** – `Tyck.ml` implements a constraint-based Hindley–Milner
   solver.  It produces pretty-printers (`Tyck.pp_inferred`) that the CLI exposes via
   `--tyck`.
4. **Normalisation passes** – `Transform.ml` contains CPS and defunctionalisation
   passes.  Pattern compilation utilities live in `Pat.ml`.
5. **Code generation** – Two back-ends consume the transformed program:
   - `CompileSeq.ml` emits a pure interpreter expressed in terms of the `Seq`
     combinators.  This is useful for comparison runs without the memo table.
   - `CompileMemo.ml` builds the memoising CEK machine using the IR DSL in
     `Code.ml`/`Ir.ml`.  It registers constructors, synthesises continuations,
     and produces one OCaml function per program point.  The CLI flag `--cek`
     pretty-prints this output.
6. **Drivers** – `bin/main.ml` wires the pipeline together, exposing flags for
   each intermediate so that developers can inspect or regenerate artifacts.

Running `make run` wraps these steps: it regenerates the compiled modules
under `generated/`, formats with `dune fmt`, and executes `GeneratedMain`.

## Runtime Representation

### Words and Sequences (`Word.ml`, `Seq.ml`)
- Data is serialised as lists of tagged machine words.  Tag `0` denotes an
  integer literal; tag `1` denotes a constructor index.  Additional tags can be
  added as needed.
- `Seq.seq` wraps a finger tree (`BatFingerTree.Generic.fg`) annotated with the
  `measure` monoid.  Each measure stores length, total degree, and the maximum
  prefix degree so that Ant can split values in logarithmic time.
- `Seq.pop_n`, `Seq.split`, and `Seq.splits` are the building blocks used by the
  memo system to carve out slices during substitution.

### Values, References, and Stores (`Value.ml`, `Reference.ml`, `State.ml`)
- `Value.seq` extends `Seq.seq` with a second measure that also carries a
  cryptographic hash (`Hash.MCRC32C`).  The hash is disabled automatically when a
  slice contains deferred `Reference` nodes, because those must be resolved later.
- References encode “holes” in a value: `{ src; offset; values_count }`.  The
  source identifies whether the data came from the environment (`E`), memo store
  (`S`), or continuation (`K`).
- `State.state` captures the CEK triple along with a step counter.  Evaluator
  transitions live in the `exp.step` closures generated by `CompileMemo.ml`.
- `State.world` bundles a state, the memo store (a `Dynarray` of values), and the
  mutable memo trie node currently being updated.

### Hashes (`Hash.ml`)
- Contains several monoid hash implementations.  `Memo` uses `MCRC32C` by
  default, but `Hash.SL2` and `Hash.DebugHash` are available for benchmarking and
  fuzzing.

## Prefix Memo Table (`Memo.ml`)

The memo trie stores execution fragments keyed by slices of CEK state.

1. **Lookup phase** – Starting from the current node, Ant issues fetch requests
   (`fetch_request`) for the environment, store, or continuation.  Each request
   asks for a fixed number of values, measured in `Seq` degrees.
2. **Fetching** – `fetch_value` loads the requested words.  If the fetch produces
   leftover prefixes/suffixes they are converted to `Reference`s and appended to
   the store so later requests can reuse them.
3. **Hashing & branching** – The fetched chunk is hashed (`fr_to_fh`) and used to
   pick the next child.  Hash collisions are theoretically possible but rare; if
   they occur Ant falls back to stepping instead of skipping.
4. **Registering progress** – `register_memo_need_unfetched` ensures that if a node
   could not fetch everything it needed we record that fact, so subsequent runs
   continue the traversal rather than starting over.
5. **Fast forwarding** – When a memoised fragment is available, `fast_forward_to`
   substitutes the live bindings into the recorded state and resumes evaluation
   from the memo target.  Substitution works recursively by calling `subst` on
   every `Reference`.

The memo trie guarantees progress by transitioning nodes through
`BlackHole -> Halfway -> Need/Done`.  Once a node reaches `Done` the enclosed CEK
state can be reused without repeating the intermediate transitions.

## Code Generation Helpers (`Code.ml`, `Ir.ml`)

- `Code.ml` offers a small EDSL for describing OCaml expressions with hole types
  such as `world -> unit`.  Functions like `lam`, `app`, `seq`, and `let_in`
  construct the IR nodes.
- `Ir.ml` defines the lower-level AST that is eventually pretty-printed.  It
  performs trivial optimisations such as flattening nested sequences so the
  generated OCaml code stays readable.
- `CompileMemo.ml` uses these helpers to stage:
  - constructor registration (`Memo.set_constructor_degree`, `Memo.from_constructor`);
  - continuation tables (the `ctx.conts` dynarray);
  - CEK program counters (`pc`) that map to `exp.step` closures.

## Generated Modules

- `generated/TestSeq.ml` and `generated/TestCEK.ml` are produced from
  `examples/Test.ant` and mirror the output of `--print-ant`/`--cek`.
- `generated/LiveCEK.ml` contains a hand-written demonstration CEK machine with
  Nat/List examples; `GeneratedMain.ml` runs it to smoke-test the memo runtime.
- These files are overwritten by `make run`.  Treat them as build artifacts.

## Testing & Benchmarking

- `test/test_ant.ml` exercises the monoid hash implementations and the custom
  integer map (`Intmap.ml`).
- Microbenchmarks in `bench/*.ml` compare the hash implementations and list
  operations.  Run them with `dune exec bench/<name>.exe`.

## Further Work

Potential areas for improvement that surfaced while reading the code:

- Finish breaking this document into smaller, topic-focused guides (memo trie,
  compiler pipeline, runtime).
- Document the CPS/defunctionalisation transformations in more depth, including
  the free-variable handling in `Transform.ml`.
- Expand the test suite to cover CEK execution traces and memo hit/miss ratios.
